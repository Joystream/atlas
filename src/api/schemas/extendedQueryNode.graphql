scalar Date

type Language {
  name: String!
}

type Membership {
  id: ID!

  handle: String!

  avatarUri: String

  controllerAccount: String!

  channels: [Channel!]!
}

union Asset = AssetUrl | AssetStorage

type AssetUrl {
  # The http url pointing to the media
  url: String!
}

type AssetStorage {
  # Upload to content directory status
  uploadStatus: AssetStorageUploadStatus!
}

union AssetStorageUploadStatus = AssetNeverProvided | AssetDeleted | AssetUploadStatus

enum LiaisonJudgement {
  PENDING
  ACCEPTED
  REJECTED
}

type AssetDataObject {
  id: ID!
  createdAt: Date!
  size: Int!
  # id of storage provider
  liaisonId: Int!
  # Storage provider as liaison judgment
  liaisonJudgement: LiaisonJudgement!
  # IPFS content id
  ipfsContentId: String!
  # Joystream runtime content
  joystreamContentId: String!
}

type Block {
  id: ID!
  block: Int!
}

type AssetUploadStatus {
  dataObject: AssetDataObject!
  oldDataObject: AssetDataObject
  happenedIn: Block!
}

type AssetDeleted {
  dataObject: AssetDataObject!
  oldDataObject: AssetDataObject
  happenedIn: Block!
}

type AssetNeverProvided {
  dataObject: AssetDataObject!
  oldDataObject: AssetDataObject
  happenedIn: Block!
}

type Channel {
  id: ID!
  createdAt: Date!
  title: String!
  description: String
  coverPhotoUrl: String
  coverPhoto: Asset
  avatarPhotoUrl: String
  avatarPhoto: Asset
  ownerMember: Membership
  isPublic: Boolean
  isCensored: Boolean
  language: Language
  videos: [Video!]!

  # extended from Orion
  follows: Int
}

# Should I name this VideosCategory?
type Category {
  id: ID!
  name: String!
  videos: [Video!]
}

type JoystreamMediaLocation {
  dataObjectId: String!
}

type HttpMediaLocation {
  url: String!
}

# In the future we can add IPFS, Dat, etc.
union MediaLocation = JoystreamMediaLocation | HttpMediaLocation

type License {
  id: ID!
  # Should be Int?
  code: String
  url: String
  attribution: String
  videoLicense: [Video!]
  customText: String
}

# TODO needs to be updated
type VideoMediaMetadata {
  id: ID!

  # Resolution width
  pixelWidth: Int!

  # Resolution height
  pixelHeight: Int!
  # Size in bytes
  size: Float

  # where to find
  location: MediaLocation!
}

type Video {
  id: ID!
  channel: Channel!
  createdAt: Date!
  createdById: String!
  updatedAt: Date
  updatedById: String
  deletedAt: Date
  # Should I name this VideoCategory?
  category: Category!
  title: String!
  description: String!
  # In seconds
  duration: Int!
  thumbnail: Asset
  thumbnailUrl: String!
  Language: Language
  hasMarketing: Boolean
  # Possible time when vide≈Ço was published before Joystream
  publishedBeforeJoystream: String
  isPublic: Boolean!
  isCensored: Boolean!
  isExplicit: Boolean!
  # In intro
  media: Asset
  mediaMetadata: VideoMediaMetadata!
  license: License!
  isFeatured: Boolean!

  skippableIntroDuration: Int
  # Timestamp of block
  createdAtBlockHeight: Float!
  # extended from Orion
  views: Int
}

type CoverVideo {
  id: ID!

  video: Video!

  coverDescription: String!

  coverCutMedia: VideoMediaMetadata!
}

type FeaturedVideo {
  id: ID!

  video: Video!
}

union SearchResult = Video | Channel

type SearchFTSOutput {
  item: SearchResult!

  rank: Float!

  isTypeOf: String!

  highlight: String!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!

  startCursor: String
  endCursor: String
}

input ChannelWhereInput {
  isCurated_eq: Boolean
  isPublic_eq: Boolean
  ownerMemberId_eq: ID
  id_in: [ID!]
}

input ChannelWhereUniqueInput {
  id: ID!
}

enum ChannelOrderByInput {
  createdAt_ASC
  createdAt_DESC
}

type ChannelEdge {
  node: Channel!
  cursor: String!
}

type ChannelConnection {
  edges: [ChannelEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input CategoryWhereUniqueInput {
  id: ID!
}

input VideoWhereInput {
  categoryId_eq: ID
  channelId_in: [ID!]
  channelId_eq: ID
  createdAt_gte: Date
  isFeatured_eq: Boolean
  isPublic_eq: Boolean
  id_in: [ID!]
}

input VideoWhereUniqueInput {
  id: ID!
}

input MembershipWhereUniqueInput {
  id: ID
}

input MembershipWhereInput {
  controllerAccount_eq: ID
}

enum VideoOrderByInput {
  createdAt_ASC
  createdAt_DESC
}

type VideoEdge {
  node: Video!
  cursor: String!
}

type VideoConnection {
  edges: [VideoEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

enum FeaturedVideoOrderByInput {
  createdAt_ASC
  createdAt_DESC
}

type Query {
  # Lookup a membership by its ID
  membership(where: MembershipWhereUniqueInput!): Membership

  # Lookup all memberships by account ID
  memberships(where: MembershipWhereInput!): [Membership!]!

  # Lookup a channel by its ID
  channel(where: ChannelWhereUniqueInput!): Channel

  # List all channels by given constraints
  channels(where: ChannelWhereInput): [Channel!]!

  # List all channel by given constraints
  channelsConnection(
    first: Int
    after: String
    where: ChannelWhereInput
    orderBy: ChannelOrderByInput
  ): ChannelConnection!

  # Lookup a channel by its ID
  category(where: CategoryWhereUniqueInput!): Category

  # List all categories
  categories: [Category!]!

  # Lookup video by its ID
  video(where: VideoWhereUniqueInput!): Video

  # Lookup videos by where params
  videos(offset: Int, limit: Int, where: VideoWhereInput): [Video!]

  # List all videos by given constraints
  videosConnection(first: Int, after: String, where: VideoWhereInput, orderBy: VideoOrderByInput): VideoConnection!

  # Get the current cover video
  coverVideo: CoverVideo!

  # List all top trending videos
  featuredVideos(orderBy: FeaturedVideoOrderByInput): [FeaturedVideo!]!

  # Free text search across videos and channels
  search(limit: Int, text: String!): [SearchFTSOutput!]!
}
