scalar DateTime
scalar BigInt

type VideoCategory {
  id: ID!
  name: String
  videos: [Video!]
}

type License {
  id: ID!
  code: Int
  attribution: String
  customText: String
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!

  startCursor: String
  endCursor: String
}

enum AssetAvailability {
  ACCEPTED
  PENDING
  INVALID
}

enum LiaisonJudgement {
  PENDING
  ACCEPTED
  REJECTED
}

enum WorkerType {
  GATEWAY
  STORAGE
}

type Worker {
  # unique ID
  id: ID!
  # ID of worker in the group, can be the same for different workers (in different groups)
  workerId: String!

  type: WorkerType!
  metadata: String
  isActive: Boolean!
}

type DataObject {
  id: ID!
  createdAt: DateTime!
  size: Float!
  # storage provider that accepted the asset
  liaison: Worker
  # status of asset as reported by liaison
  liaisonJudgement: LiaisonJudgement!
  # IPFS content id
  ipfsContentId: String!
  # Joystream runtime content id
  joystreamContentId: String!
  videomediaDataObject: [Video!]
  videothumbnailPhotoDataObject: [Video!]
}

input DataObjectWhereInput {
  joystreamContentId_eq: String
  joystreamContentId_in: [String!]
}

type StorageDataObject {
  id: ID!
  createdAt: DateTime!

  # Whether the data object was uploaded and accepted by the storage provider
  isAccepted: Boolean!

  # Data object size in bytes
  size: BigInt!
  storageBag: StorageBag!
  storageBagId: String!

  # IPFS content hash
  ipfsHash: String!

  # The type of the asset that the data object represents (if known)
  type: DataObjectType!

  # Prize for removing the data object
  deletionPrize: Float!
}

type StorageBag {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
  objects: [StorageDataObject!]!
  storageBuckets: [StorageBucket!]!
  distributionBuckets: [DistributionBucket!]!

  # Owner of the storage bag
  owner: StorageBagOwner!
}

type StorageBucket {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!

  # Current bucket operator status
  operatorStatus: StorageBucketOperatorStatus!
  operatorMetadata: StorageBucketOperatorMetadata
  operatorMetadataId: String

  # Whether the bucket is accepting any new storage bags
  acceptingNewBags: Boolean!
  bags: [StorageBag!]!

  # Bucket's data object size limit in bytes
  dataObjectsSizeLimit: Float!

  # Bucket's data object count limit
  dataObjectCountLimit: Float!

  # Number of assigned data objects
  dataObjectsCount: Float!

  # Total size of assigned data objects
  dataObjectsSize: Float!
}

union StorageBucketOperatorStatus =
    StorageBucketOperatorStatusMissing
  | StorageBucketOperatorStatusInvited
  | StorageBucketOperatorStatusActive

type StorageBucketOperatorStatusMissing {
  phantom: Int
}

type StorageBucketOperatorStatusInvited {
  workerId: Int!
}

type StorageBucketOperatorStatusActive {
  workerId: Int!
}

type StorageBucketOperatorMetadata {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!

  # Root node endpoint
  nodeEndpoint: String
  nodeLocation: NodeLocationMetadata
  nodeLocationId: String

  # Additional information about the node/operator
  extra: String
}

type NodeLocationMetadata {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!

  # ISO 3166-1 alpha-2 country code (2 letters)
  countryCode: String

  # City name
  city: String
  coordinates: GeoCoordinates
  coordinatesId: String
}

type GeoCoordinates {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
  latitude: Float!
  longitude: Float!
}

type DistributionBucketOperatorMetadata {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!

  # Root distributor node api endpoint
  nodeEndpoint: String
  nodeLocation: NodeLocationMetadata
  nodeLocationId: String

  # Additional information about the node/operator
  extra: String
}

type DistributionBucketOperator {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
  distributionBucket: DistributionBucket!
  distributionBucketId: String!

  # ID of the distribution group worker
  workerId: Int!

  # Current operator status
  status: DistributionBucketOperatorStatus!
  metadata: DistributionBucketOperatorMetadata
  metadataId: String
}

enum DistributionBucketOperatorStatus {
  INVITED
  ACTIVE
}

type DistributionBucket {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
  family: DistributionBucketFamily!
  familyId: String!
  operators: [DistributionBucketOperator!]!

  # Whether the bucket is accepting any new bags
  acceptingNewBags: Boolean!

  # Whether the bucket is currently distributing content
  distributing: Boolean!
  bags: [StorageBag!]!
}

type DistributionBucketFamily {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
  metadata: DistributionBucketFamilyMetadata
  metadataId: String
  buckets: [DistributionBucket!]!
}

type DistributionBucketFamilyMetadata {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!

  # Name of the geographical region covered by the family (ie.: us-east-1)
  region: String

  # Optional, more specific description of the region covered by the family
  description: String
  areas: [DistributionBucketFamilyGeographicArea!]!

  # List of targets (hosts/ips) best suited latency measurements for the family
  latencyTestTargets: [String!]
}

type DistributionBucketFamilyGeographicArea {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!

  # Geographical area (continent / country / subdivision)
  area: GeographicalArea!
  distributionBucketFamilyMetadata: DistributionBucketFamilyMetadata!
  distributionBucketFamilyMetadataId: String!
}

union GeographicalArea = GeographicalAreaContinent | GeographicalAreaCountry | GeographicalAreaSubdivistion

type GeographicalAreaContinent {
  code: Continent
}

enum Continent {
  AF
  NA
  OC
  AN
  AS
  EU
  SA
}

type GeographicalAreaCountry {
  # ISO 3166-1 alpha-2 country code
  code: String
}

type GeographicalAreaSubdivistion {
  # ISO 3166-2 subdivision code
  code: String
}

union StorageBagOwner =
    StorageBagOwnerCouncil
  | StorageBagOwnerWorkingGroup
  | StorageBagOwnerMember
  | StorageBagOwnerChannel
  | StorageBagOwnerDAO

type StorageBagOwnerCouncil {
  phantom: Int
}

type StorageBagOwnerWorkingGroup {
  workingGroupId: String
}

type StorageBagOwnerMember {
  memberId: Int
}

type StorageBagOwnerChannel {
  channelId: Int
}

type StorageBagOwnerDAO {
  daoId: Int
}

union DataObjectType =
    DataObjectTypeChannelAvatar
  | DataObjectTypeChannelCoverPhoto
  | DataObjectTypeVideoMedia
  | DataObjectTypeVideoThumbnail
  | DataObjectTypeUnknown

type DataObjectTypeChannelAvatar {
  # Related channel entity
  channel: Channel
}

type DataObjectTypeChannelCoverPhoto {
  # Related channel entity
  channel: Channel
}

type DataObjectTypeVideoMedia {
  # Related video entity
  video: Video
}

type DataObjectTypeVideoThumbnail {
  # Related video entity
  video: Video
}

type DataObjectTypeUnknown {
  phantom: Int
}

input StorageDataObjectWhereInput {
  isAccepted_eq: Boolean
}

input StorageBagWhereInput {
  id_eq: ID
  id_in: [ID!]

  AND: [StorageBagWhereInput!]
  OR: [StorageBagWhereInput!]
}

input DistributionBucketWhereInput {
  id_eq: ID
  id_in: [ID!]

  acceptingNewBags_eq: Boolean
  distributing_eq: Boolean
  distributing_in: [Boolean!]

  bags_none: StorageBagWhereInput
  bags_some: StorageBagWhereInput
  bags_every: StorageBagWhereInput

  AND: [DistributionBucketWhereInput!]
  OR: [DistributionBucketWhereInput!]
}

type Membership {
  id: ID!
  handle: String!
  avatarUri: String
  controllerAccount: String!
  about: String
  channels: [Channel!]!
}

input MembershipWhereUniqueInput {
  id: ID
  handle: String
}

input MembershipWhereInput {
  controllerAccount_eq: ID
  controllerAccount_in: [ID!]
}

type Channel {
  id: ID!
  createdAt: DateTime!

  ownerMember: Membership
  videos: [Video!]!
  isCensored: Boolean!

  # === metadata ===
  title: String
  description: String
  isPublic: Boolean
  language: Language

  # === assets ===
  coverPhoto: StorageDataObject
  avatarPhoto: StorageDataObject

  # === extended from Orion ===
  follows: Int
  views: Int
}

input ChannelWhereInput {
  id_eq: ID
  id_in: [ID!]

  isCurated_eq: Boolean
  isPublic_eq: Boolean
  isCensored_eq: Boolean

  ownerMember: MembershipWhereInput
  language: LanguageWhereInput
  coverPhoto: DataObjectWhereInput
  avatarPhoto: DataObjectWhereInput
}

input ChannelWhereUniqueInput {
  id: ID!
}

enum ChannelOrderByInput {
  createdAt_ASC
  createdAt_DESC
}

type ChannelEdge {
  node: Channel!
  cursor: String!
}

type ChannelConnection {
  edges: [ChannelEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type VideoMediaMetadata {
  id: ID!

  pixelWidth: Int
  pixelHeight: Int
  # Size in bytes
  size: Int
}

type Video {
  id: ID!
  createdAt: DateTime!
  channel: Channel!
  isCensored: Boolean!
  isFeatured: Boolean!
  publishedBeforeJoystream: DateTime

  # === metadata ===
  title: String
  description: String
  category: VideoCategory
  language: Language
  hasMarketing: Boolean
  isExplicit: Boolean
  isPublic: Boolean
  license: License

  # === assets ===
  media: StorageDataObject
  mediaMetadata: VideoMediaMetadata
  thumbnailPhoto: StorageDataObject

  # In seconds
  duration: Int
  skippableIntroDuration: Int

  # === extended from Orion ===
  views: Int
}

input VideoCategoryWhereUniqueInput {
  id: ID!
}

input VideoWhereInput {
  id_eq: ID
  id_in: [ID!]

  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime

  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime

  title_eq: String
  title_contains: String
  title_startsWith: String
  title_endsWith: String
  title_in: [String!]

  description_eq: String
  description_contains: String
  description_startsWith: String
  description_endsWith: String
  description_in: [String!]

  duration_eq: Int
  duration_gt: Int
  duration_gte: Int
  duration_lt: Int
  duration_lte: Int
  duration_in: [Int!]

  publishedBeforeJoystream_eq: DateTime
  publishedBeforeJoystream_lt: DateTime
  publishedBeforeJoystream_lte: DateTime
  publishedBeforeJoystream_gt: DateTime
  publishedBeforeJoystream_gte: DateTime

  isPublic_eq: Boolean
  isCensored_eq: Boolean
  isExplicit_eq: Boolean
  isFeatured_eq: Boolean
  hasMarketing_eq: Boolean

  channel: ChannelWhereInput
  category: VideoCategoryWhereInput
  thumbnailPhoto: StorageDataObjectWhereInput
  language: LanguageWhereInput
  license: LicenseWhereInput
  media: StorageDataObjectWhereInput
  mediaMetadata: VideoMediaMetadataWhereInput

  AND: [VideoWhereInput!]
  OR: [VideoWhereInput!]
}

input VideoCategoryWhereInput {
  id_eq: ID
  id_in: [ID!]
}

input LanguageWhereInput {
  id_eq: ID
  iso_eq: String
}

input VideoMediaMetadataWhereInput {
  id_eq: ID
}

input LicenseWhereInput {
  id_eq: ID
  code_eq: Int
}

input VideoWhereUniqueInput {
  id: ID!
}

enum VideoOrderByInput {
  createdAt_ASC
  createdAt_DESC
}

type VideoEdge {
  node: Video!
  cursor: String!
}

type VideoConnection {
  edges: [VideoEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input WorkerWhereInput {
  metadata_contains: String
  isActive_eq: Boolean
  type_eq: WorkerType
}

input WorkerWhereUniqueInput {
  id: ID!
}

enum WorkerOrderByInput {
  createdAt_ASC
  createdAt_DESC
}

union SearchResult = Video | Channel

type SearchFTSOutput {
  item: SearchResult!
  rank: Float!
  isTypeOf: String!
  highlight: String!
}

type ProcessorState {
  lastCompleteBlock: Float!
  lastProcessedEvent: String!
  indexerHead: Float!
  chainHead: Float!
}

type Language {
  id: ID!
  iso: String!
}

type Query {
  # Lookup a membership by its ID
  membershipByUniqueInput(where: MembershipWhereUniqueInput!): Membership

  # Lookup all memberships by account ID
  memberships(where: MembershipWhereInput!): [Membership!]!

  # Lookup a channel by its ID
  channelByUniqueInput(where: ChannelWhereUniqueInput!): Channel

  # List all channels by given constraints
  channels(offset: Int, limit: Int, orderBy: [ChannelOrderByInput!], where: ChannelWhereInput): [Channel!]!

  # List all channel by given constraints
  channelsConnection(
    first: Int
    after: String
    where: ChannelWhereInput
    orderBy: [ChannelOrderByInput!]
  ): ChannelConnection!

  # Lookup video by its ID
  videoByUniqueInput(where: VideoWhereUniqueInput!): Video

  # Lookup videos by where params
  videos(offset: Int, limit: Int, where: VideoWhereInput, orderBy: [VideoOrderByInput!]): [Video!]

  # List all videos by given constraints
  videosConnection(first: Int, after: String, where: VideoWhereInput, orderBy: [VideoOrderByInput!]): VideoConnection!

  # List all categories
  videoCategories: [VideoCategory!]!

  workers(offset: Int, limit: Int, where: WorkerWhereInput): [Worker!]

  workerByUniqueInput(where: WorkerWhereUniqueInput!): Worker

  # Free text search across videos and channels
  search(limit: Int, text: String!, whereVideo: VideoWhereInput, whereChannel: ChannelWhereInput): [SearchFTSOutput!]!

  dataObjects(limit: Int, where: DataObjectWhereInput): [DataObject!]!

  distributionBuckets(offset: Int, limit: Int, where: DistributionBucketWhereInput): [DistributionBucket!]!
}

type Subscription {
  stateSubscription: ProcessorState!
}
